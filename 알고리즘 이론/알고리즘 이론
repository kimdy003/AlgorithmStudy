그리디 알고리즘
    -현재 상황에서 지금 당장 좋은 것만 고르는 방법
    -> 매 순간 가장 좋아 보이는 것만 선택하고, 현재의 선택이 나중에 미칠 영향에
        미칠 영향에 대해서는 고려하지 않는다
    ex) 거스름돈 문제 -> 가장 큰 화페 단위부터 돈을 거슬러 주기

 그리디 알고리즘의 정당성
    -탐욕적으로 문제에 접근 시 정확한 답을 찾을 수 있다는 보당이 있을 때는 매우 효과적이고 직관적
    -문제의 해법을 찾았을 때는 그 해법이 정당한지 검토

    ex) 거스름돈 문제
        -검토: 가지고 있는 동전 중 가장 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 
                동전들을 종합해 다른 해가 나올 수 없다.

 결론: 대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를
        떠올리고 이것을 정당한지 검토할 수 있어야한다.

===============================================================================================

구현 
    -머리속에 있는 알고리즘을 코드로 바꾸는 과정
    -모든 범위의 코딩 테스트 문제 유형을 포함하는 개념
    1. 완전 탐색
        -모든 경우의 수를 주저 없이 다 계산 하는 해결 방법

    2. 시뮬레이션
        -문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

===============================================================================================

정렬 알고리즘
    1. 선택정렬
    2. 삽입정렬
    3. 퀵 정렬

===============================================================================================

탐색 알고리즘
    1. 순차 탐색
        데이터를 하나씩 차례대로 확인

    2. 이분 탐색
        -정렬이 되어있는 데이터 상에서 가능
        -찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교

===============================================================================================

최단 경로 알고리즘
    1-1. 다익스트라 최단 경로 알고리즘
        -'특정한 노드에서 출발'하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
        -음의 간선이 없을 때 사용 (중요!!)
        -그리디 알고리즘으로 분류
            (1) 출발 노드를 설정
            (2) 최단 거리 배열을 무한으로 초기화
            (3) 방문 하지 않는 노드 중에서 최단 거리가 가장 짧은 노드를 선택
            (4) 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 배열을 갱신
            (5) (3)~(4)번 반복
    
    1-2. 벨만포드 알고리즘
        -다익스트라 알고리즘과 마찬가지로 시작점을 정해 주면 다른 모든 정점으로의 최단 경로를 구함
        -But, 이 알고리즘은 간선 cost가 음수일 때도 사용 가능 (시간이 오래 걸림 O(ve))
        -2중 for문을 통해 철저히 가능한 모든 경우를 다 체크
            (1) 출발 노드를 설정
            (2) 최단 거리 배열을 무한으로 설정
            (3) 현재의 정점의 모든 인접 정점들을 탐색하며, 최단 거리 배열을 갱신
            (4) (3)번 과정을 'V-1'번 반복 (그래프에서 시작 정점에서 특정 정점까지 도달하기 위해 거쳐가는 최대 간선의 수는 V-1개(정점의 개수 - 1) 이기 때문에)
            +) 위 과정을 마친 후에도 거리가 갱신되는 경우가 있다면 그래프의 음수 사이클이 존재한다는 것!


    2. 플로이드 워샬 알고리즘
        -'모든 정점' 사이의 최단 거리를 구하는 알고리즘
        -음의 사이클이 없는 그래프에서 가능
        -2차원의 배열을 사용
        -dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j]);

===============================================================================================

그래프 알고리즘
    1.Union-Find 연산(= 서로소 집합)
        -트리를 만들어가는 연산
        -트리 자료구조를 이용하여 집합을 표현
            (1) Union 연산을 확인하여 서로 연결된 두 노드 A, B를 찾는다.
            (2) A와 B의 루트 노드 R_A, R_B를 찾는다.
            (3) R_A를 R_B의 부모 노드로 설정
        
    ver 2.
        -경로 압축기법 사용
        -재귀로 루트 노드를 찾으면서 부모 테이블 갱신
            * parent[x] = Find(parent[x]);
        ex)
        (4, 5) (3, 4) (2, 3) (2, 1)
        1 <- 2 <- 3 <- 4 <- 5
        노드 5인 경우 5번을 올라가고, 노드 4인 경우 4번...

        그러나 부모 테이브를 갱신을 하면
        1 <- 2  //  1 <- 3
        1 <- 4  //  1 <- 5  가 되어 노드 5번만 5번을 올라가고,
        나머지 노드는 한번 씩만 올라간다.
        
    사이클 판별
        -Union_Find 연산을 통해 사이클 판별 가능
            (1) 각 간선을 확인하며 두 노드의 루트 노드를 확인
                i. 루트 노드가 서로 다르다면 두 노드에 대하여 Union 연산 수행
                ii. 루트 노드가 서로 같다면 사이클(Cycle) 발생

    2. 최소 스패닝 트리(= 최소 신장 트리, MST)
        -하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미
        #. 크루스칼 알고리즘
            -최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘
                (1) 간선 데이터를 비용에 따라 오름차순 정렬
                (2) 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
                    i. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함
                    ii. 사이클이 발생한 경우 무시
                
        #. 프림 알고리즘
            -그래프의 틀을 유지해 나가면서 MST를 형성(크루스칼 알고리즘과의 차이점)
                (1) 임의의 시작점 하나를 선택
                (2) 이 시작점과 연결된 정점들의 거리를 갱신
                (3) 선택된 정점들과 연결되어 있는 간선들 중에서, 가장 길이가 짧은 간선을 선택해서 연결
                (4) 가장 짧은 간선으로 연결되어 있는 정점을 선택하고, 정점들의 거리를 갱신
                (5) 위 과정을 (전체 노드 - 1)번 반복 
        
    3. 위상 정렬
        -순서가 정해져 있는 일련의 작업을 차례대로 수행 할 때 수행
        -방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열'
            (1) 진입차수가 '0'인 노드를 큐에 넣기
            (2) 큐가 빌 때까지 반복
                i. 큐에서 원소를 꺼내 해당 노드에서 출발하는 간선을 그래프에서 제거
                ii. 새롭게 진입차수가 '0'이 된 노드를 큐에 넣기

            *위상 정렬은 답이 여러개가 가능

        +) 진입차수 : 특정한 노드로 '들어오는' 간선의 개수
    

===============================================================================================

트리 알고리즘
    1. TRIE 알고리즘
        -문자열을 정렬해주는 알고리즘
    
    2. 세그먼트 트리
    
    3. LCA(Lowest Common Ancestor) 알고리즘
        -두 정점에서 가장 가까운 공통 조상을 찾는 알고리즘
        -DP를 사용하여 해결(or 세그먼트 트리를 사용해도 됨)
            (1) depth와 조상을 사지는 트리를 생성(이때 조상은 2^k형태(0<=k))
            (2) depth가 더 깊은 노드를 depth가 더 낮은 노드까지 올려준다
            (3) 같은 depth를 가지는 노드가 만들어지면, 2^k만큼 조상을 올라가면서
                조상이 같아질 때까지 노드를 타고 올라간다.

===============================================================================================

기타 알고리즘
    1. 투 포인트
    2. 구간 합 계산 알고리즘

================================================================================================

기타

LCS(Longest Common Substring) - 공통 부분 문자열
LCS(Longest Common Subsequence) - 공통 부분 수열
2개를 구분해줘야함 차이점은 -연속 여부-
    공통 부분 문자열
        : (ABCDHEF, BCDEF) => BCD
    공통 부분 수열
        : (ABCDHEF, BCDEF) => BCDEF


* 공통 부분 문자열
    if s1[p] == s2[q]:
        LCCS(s1[p-1], s2[q-1]) + 1
    else:
        0

* 공통 부분 문자열
    if s1[p] == s2[q]:
        LCS(s1[p-1], s2[q-1]) + 1
    else:
        max( LCS(s1[p-1], s2[q]),  LCS(s1[p], s2[q-1]) )